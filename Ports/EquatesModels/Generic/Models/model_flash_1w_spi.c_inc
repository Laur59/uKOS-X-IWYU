/*
; model_flash_1w_spi.
; ===================

;------------------------------------------------------------------------
; Author:	Edo. Franzi		The 2025-01-01
; Modifs:
;
; Project:	uKOS-X
; Goal:		Model for controlling the "flash" 1-Wire device by an SPI.
;
;   (c) 2025-20xx, Edo. Franzi
;   --------------------------
;                                              __ ______  _____
;   Edo. Franzi                         __  __/ //_/ __ \/ ___/
;   5-Route de Cheseaux                / / / / ,< / / / /\__ \
;   CH 1400 Cheseaux-NorÃ©az           / /_/ / /| / /_/ /___/ /
;                                     \__,_/_/ |_\____//____/
;   edo.franzi@ukos.ch
;
;   Description: Lightweight, real-time multitasking operating
;   system for embedded microcontroller and DSP-based systems.
;
;   Permission is hereby granted, free of charge, to any person
;   obtaining a copy of this software and associated documentation
;   files (the "Software"), to deal in the Software without restriction,
;   including without limitation the rights to use, copy, modify,
;   merge, publish, distribute, sublicense, and/or sell copies of the
;   Software, and to permit persons to whom the Software is furnished
;   to do so, subject to the following conditions:
;
;   The above copyright notice and this permission notice shall be
;   included in all copies or substantial portions of the Software.
;
;   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   SOFTWARE.
;
;------------------------------------------------------------------------
*/

// Prototypes

static	void	local_flash_1w_erase(uint32_t size, uint32_t sector);

/*
 * \brief model_flash_1w_init
 *
 * - Initialise some specific parts
 *
 */
void	model_flash_1w_init(void) {

	cb_control(KFLASH_INIT);
}

/*
 * \brief model_flash_1w_initialise
 *
 * - Initialise the flash
 *
 */
int32_t	model_flash_1w_initialise(void) {

	return (KERR_STORAGE_NOERR);
}

/*
 * \brief model_flash_1w_readStatus
 *
 * - Read the status of the card (only inserted)
 *
 */
int32_t	model_flash_1w_readStatus(void) {

	return (KERR_STORAGE_NOERR);
}

/*
 * \brief model_flash_1w_read
 *
 * - Read from the flash 1 or more sectors
 *
 */
int32_t	model_flash_1w_read(uint8_t *buffer, uint32_t size, uint32_t sector) {
	uint8_t		*wkBuffer = buffer;
	uint32_t	address, index;

	if (size == 0u) {
		return (KERR_STORAGE_NOERR);
	}

	cb_control(KFLASH_RESERVE_SPI);
	address = sector * KFLASH_SPI_SZ_SECTOR;

// A read cycle 0x03u 0xAAu 0xAAu 0xAAu 0x00u
// 0x03u --> Read order
// 0xAAu --> 24-bit address

	kern_waitAtLeast(1);
	cb_control(KFLASH_SELECT);
	cb_writeRead(KFLASH_SPI_CMD_READ);
	cb_writeRead((uint8_t)(address>>16u));
	cb_writeRead((uint8_t)(address>>8u));
	cb_writeRead((uint8_t)(address));

	for (index = 0u; index < size; index++) {
		*wkBuffer = cb_writeRead(0x00u);
		wkBuffer++;
	}
	cb_control(KFLASH_DESELECT);
	cb_control(KFLASH_RELEASE_SPI);
	return (KERR_STORAGE_NOERR);
}

/*
 * \brief model_flash_1w_write
 *
 * - Write pages
 * - This function writes pages. If a page is not complete
 *   this system call complete it with an unpredictable content
 *
 */
int32_t	model_flash_1w_write(const uint8_t *buffer, uint32_t size, uint32_t sector) {
			uint32_t	address, index, pages, nbPages;
	const	uint8_t		*wkBuffer = buffer;

	if (size == 0u) {
		return (KERR_STORAGE_NOERR);
	}

	cb_control(KFLASH_RESERVE_SPI);
	local_flash_1w_erase(size, sector);

	address = sector * KFLASH_SPI_SZ_SECTOR;
	nbPages = size / KFLASH_SPI_SZ_PAGE;

// Write complete pages of 256-bytes
// In case of the page is not complete,
// the page is completed with dummy data

	for (pages = 0u; pages < nbPages; pages++) {
		kern_waitAtLeast(1u);
		cb_control(KFLASH_SELECT);
		cb_writeRead(KFLASH_SPI_CMD_WRITE_ENABLE);
		cb_control(KFLASH_DESELECT);

// Write a page 0x02u 0xAAu 0xAAu 0xAAu (256 x 0xDD) (waiting for 5-ms)
// 0x02u --> Write order
// 0xAAu --> 24-bit address (boundary of 256-bytes)
// 0xDDu --> 256 x Data

		kern_waitAtLeast(1);
		cb_control(KFLASH_SELECT);
		cb_writeRead(KFLASH_SPI_CMD_WRITE);
		cb_writeRead((uint8_t)(address>>16u));
		cb_writeRead((uint8_t)(address>>8u));
		cb_writeRead((uint8_t)(address));

		for (index = 0u; index < KFLASH_SPI_SZ_PAGE; index++) {
			cb_writeRead(*wkBuffer);
			wkBuffer++;
		}
		cb_control(KFLASH_DESELECT);
		kern_suspendProcess(10u);
		address += KFLASH_SPI_SZ_PAGE;
	}
	cb_control(KFLASH_RELEASE_SPI);
	return (KERR_STORAGE_NOERR);
}

/*
 * \brief model_flash_1w_ioctl
 *
 * - Read some flash parameters
 *
 */
int32_t	model_flash_1w_ioctl(storageIoctl_t command, void *buffer) {

	switch (command) {
		case KGET_BLOCK_SIZE: {
			*(uint32_t *)buffer = 1u;
			break;
		}
		case KGET_SECTOR_SIZE: {
			*(uint16_t *)buffer = KFLASH_SZ_SECTOR;
			break;
		}
		case KGET_SECTOR_COUNT: {
			*(uint32_t *)buffer = KFLASH_NB_SECORS;
			break;
		}
		default: {

// Make MISRA happy :-)

			break;
		}
	}
	return (KERR_STORAGE_NOERR);
}

// Local routines
// ==============

/*
 * \brief model_flash_1w_erase
 *
 * - Erase sectors
 *
 */
static	void	local_flash_1w_erase(uint32_t size, uint32_t sector) {
	uint32_t	nbSectors, address;

	address	  = sector * KFLASH_SPI_SZ_SECTOR;
	nbSectors = size / KFLASH_SPI_SZ_SECTOR;

	for (sector = 0u; sector < nbSectors; sector++) {
		kern_waitAtLeast(1u);
		cb_control(KFLASH_SELECT);
		cb_writeRead(KFLASH_SPI_CMD_WRITE_ENABLE);
		cb_control(KFLASH_DESELECT);

// Erase a sector 4-KBytes
// 0x20u --> Sector erase order
// 0xAAu --> 24-bit address (boundary of 4-KBytes)

		kern_waitAtLeast(1u);
		cb_control(KFLASH_SELECT);
		cb_writeRead(KFLASH_SPI_CMD_ERASE_SECTOR);
		cb_writeRead((uint8_t)(address>>16u));
		cb_writeRead((uint8_t)(address>>8u));
		cb_writeRead((uint8_t)(address));
		cb_control(KFLASH_DESELECT);
		kern_suspendProcess(240u);
		address += KFLASH_SPI_SZ_SECTOR;
	}
}
