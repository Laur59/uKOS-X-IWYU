/*
; model_cache.
; ============

;------------------------------------------------------------------------
; Author:	Edo. Franzi		The 2025-01-01
; Modifs:
;
; Project:	uKOS-X
; Goal:		Cortex M33 cache management.
;
;   (c) 2025-20xx, Edo. Franzi
;   --------------------------
;                                              __ ______  _____
;   Edo. Franzi                         __  __/ //_/ __ \/ ___/
;   5-Route de Cheseaux                / / / / ,< / / / /\__ \
;   CH 1400 Cheseaux-NorÃ©az           / /_/ / /| / /_/ /___/ /
;                                     \__,_/_/ |_\____//____/
;   edo.franzi@ukos.ch
;
;   Description: Lightweight, real-time multitasking operating
;   system for embedded microcontroller and DSP-based systems.
;
;   Permission is hereby granted, free of charge, to any person
;   obtaining a copy of this software and associated documentation
;   files (the "Software"), to deal in the Software without restriction,
;   including without limitation the rights to use, copy, modify,
;   merge, publish, distribute, sublicense, and/or sell copies of the
;   Software, and to permit persons to whom the Software is furnished
;   to do so, subject to the following conditions:
;
;   The above copyright notice and this permission notice shall be
;   included in all copies or substantial portions of the Software.
;
;   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   SOFTWARE.
;
;------------------------------------------------------------------------
*/

// Prototypes

static	inline	void local_init(DCACHE_TypeDef *cache);
static	inline	void local_commandByAddress(DCACHE_TypeDef *cache, uint32_t command, const void *address, int32_t size);

#define	DCACHE_COMMAND_CLEAN				(1u * DCACHE_CR_CACHECMD_0)
#define	DCACHE_COMMAND_INVALIDATE			(2u * DCACHE_CR_CACHECMD_0)
#define	DCACHE_COMMAND_CLEAN_INVALIDATE		(3u * DCACHE_CR_CACHECMD_0)

/*
 * \brief cache_D_Enable
 *
 * - Enable the data cache
 *
 */
static	inline	void	cache_D_Enable(uint8_t unit) {
	DCACHE_TypeDef	*cache = DCACHE1_NS;

	cache = (unit == 0u) ? (DCACHE1_NS) : (DCACHE2_NS);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

	local_init(cache);

// Check no ongoing operation

	while ((cache->SR & (DCACHE_SR_BUSYF | DCACHE_SR_BUSYCMDF)) != 0u) { ; }

// Enable D-Cache

	cache->CR |= DCACHE_CR_EN;

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_D_Disable
 *
 * - Disable the data cache
 *
 */
static	inline	void	cache_D_Disable(uint8_t unit) {
	DCACHE_TypeDef	*cache = DCACHE1_NS;

	cache = (unit == 0u) ? (DCACHE1_NS) : (DCACHE2_NS);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

	local_init(cache);

// Disable D-Cache

	cache->CR &= ~DCACHE_CR_EN;

// Check no ongoing operation

	while ((cache->SR & (DCACHE_SR_BUSYF | DCACHE_SR_BUSYCMDF)) != 0u) { ; }

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_D_Invalidate
 *
 * - Invalidate the data cache
 *
 */
static	inline	void	cache_D_Invalidate(uint8_t unit) {
	DCACHE_TypeDef	*cache = DCACHE1_NS;

	cache = (unit == 0u) ? (DCACHE1_NS) : (DCACHE2_NS);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

	local_init(cache);

// Check no ongoing operation

	while ((cache->SR & (DCACHE_SR_BUSYF | DCACHE_SR_BUSYCMDF)) != 0u);

// Make sure flags are reset
// Set no operation on address range
// Launch cache invalidation

	cache->FCR |= (DCACHE_FCR_CBSYENDF | DCACHE_FCR_CCMDENDF);
	cache->CR  &= ~DCACHE_CR_CACHECMD;
	cache->CR  |=  DCACHE_CR_CACHEINV;

// Wait for end of cache invalidation

	while ((cache->SR & DCACHE_SR_BUSYF) != 0u) { ; }

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_D_Invalidate_Add
 *
 * - Invalidate the data cache by address
 *
 */
static	inline	void	cache_D_Invalidate_Add(uint8_t unit, const void *address, int32_t size) {
	DCACHE_TypeDef	*cache = DCACHE1_NS;

	cache = (unit == 0u) ? (DCACHE1_NS) : (DCACHE2_NS);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

	local_init(cache);
	local_commandByAddress(cache, DCACHE_COMMAND_INVALIDATE, address, size);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_D_Clean_Add
 *
 * - Clean the data cache by address
 *
 */
static	inline	void	cache_D_Clean_Add(uint8_t unit, const void *address, int32_t size) {
	DCACHE_TypeDef	*cache = DCACHE1_NS;

	cache = (unit == 0u) ? (DCACHE1_NS) : (DCACHE2_NS);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

	local_init(cache);
	local_commandByAddress(cache, DCACHE_COMMAND_CLEAN, address, size);

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_I_Enable
 *
 * - Enable the instruction cache
 *
 */
static	inline	void	cache_I_Enable(void) {

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

// Enable I-Cache

	ICACHE_NS->CR |= ICACHE_CR_EN;

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_I_Disable
 *
 * - Disable the instruction cache
 *
 */
static	inline	void	cache_I_Disable(void) {

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

// Make sure BSYENDF is reset before to disable the instruction cache
// as it automatically starts a cache invalidation procedure

	ICACHE_NS->FCR = ICACHE_FCR_CBSYENDF;
	ICACHE_NS->CR &= ~ICACHE_CR_EN;

// Waiting for instruction cache being disabled

	while ((ICACHE_NS->CR & ICACHE_CR_EN) != 0u) { ; }

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

/*
 * \brief cache_I_Invalidate
 *
 * - Invalidate the instruction cache
 *
 */
static	inline	void	cache_I_Invalidate(void) {

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;

// Check no ongoing operation

	while ((ICACHE_NS->SR & ICACHE_SR_BUSYF) != 0u) { ; }

// Make sure BSYENDF is reset before to start cache invalidation
// Launch cache invalidation

	ICACHE_NS->FCR = ICACHE_FCR_CBSYENDF;
	ICACHE_NS->CR |= ICACHE_CR_CACHEINV;

// Waiting for the end of invalidation

	if ((ICACHE_NS->SR & ICACHE_SR_BUSYF) != 0u) {
		while ((ICACHE_NS->SR & ICACHE_SR_BSYENDF) == 0u) { ; }
	}

// Clear BSYENDF

	ICACHE_NS->FCR = ICACHE_FCR_CBSYENDF;

	DATA_SYNC_BARRIER;
	INST_SYNC_BARRIER;
}

// Local routines
// ==============

/*
 * \brief local_init
 *
 */
static	inline	void local_init(DCACHE_TypeDef *cache) {

	if ((cache->CR & DCACHE_CR_EN) != 0u) {
		return;
	}

// Output burst type for cache master port read accesses (INCR)

	cache->CR |= DCACHE_CR_HBURST;
}

/*
 * \brief local_commandByAddress
 *
 */
static	inline	void local_commandByAddress(DCACHE_TypeDef *cache, uint32_t command, const void *address, int32_t size) {

// Check no ongoing operation

	while ((cache->SR & (DCACHE_SR_BUSYF | DCACHE_SR_BUSYCMDF)) != 0u) { ; }

// Make sure flags are reset
// Fill area start address
// Fill area end address
// Set command

	cache->FCR		 |= (DCACHE_FCR_CBSYENDF | DCACHE_FCR_CCMDENDF);
	cache->CMDRSADDRR = (uint32_t)address;
	cache->CMDREADDRR = (uint32_t)((uint32_t)address + (uint32_t)size - 1u);
	cache->CR		 &= ~DCACHE_CR_CACHECMD;
	cache->CR		 |= command;

// Launch cache command

	cache->CR |= DCACHE_CR_STARTCMD;

// Wait for end of cache command

	while ((cache->SR & DCACHE_SR_CMDENDF) == 0u) { ; }
}
